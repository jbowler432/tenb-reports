import os.path, sys
sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), os.pardir))
import tenbIOcore as tc
import utilities as ut
import reportTemplates as rt
import datetime

'''
Produces a html report showing all vulnerabilities that are exploitable.
get_new_data controls whether you want a fresh dump of the vuln export database.
Example provided shows how you can use a tag based filter to limit the downloaded results.
If no fresh data is downloaded, then it assumes the json file (results_file)
of old vuln data still exists to produce the report.
'''

# file and directory locations
key_file="../../io_keys.json" # location of your key file
results_dir="../results/" # the directory for your results
styles_dir="../styles/" #style sheet location for web pages
reports_dir="../report_samples/"

api_keys=tc.read_keys(key_file,"sandbox")
get_new_data=0
results_file=results_dir+"vulns.json"
reports_file=reports_dir+"exploitable_vulns.html"

# get new vuln data if required
if get_new_data==1:
	# export some vuln data
	num_assets=50
	filters={
		"tag.Essential8":["Internal","Internet-Facing"]
	}
	payload={
		"filters": filters,
		"num_assets": num_assets
	}
	chunk_results=tc.check_and_download_vuln_chunks(api_keys,payload,results_file)

# process the download vuln file and produce the report
decoded=ut.read_json_file(results_file)
values_to_print=["asset","plugin"]
exploitable_vulns={}
for x in decoded:
	#print(x['asset'])
	exploitable=x["plugin"]["exploit_available"]
	pid=x["plugin"]["id"]
	pdesc=x["plugin"]["description"]
	pname=x["plugin"]["name"]
	psolution=x["plugin"]["solution"]
	psynopsis=''
	if 'synopsis' in x['plugin']:
		psynopsis=x["plugin"]["synopsis"]
	ipv4=x["asset"]["ipv4"]
	hostname=''
	if 'hostname' in x['asset']:
		hostname=x["asset"]["hostname"]
	severity=x["severity"]
	if exploitable==True:
		if pid in exploitable_vulns:
			assets=exploitable_vulns[pid]["assets"]
			assets.append(ipv4)
			count=exploitable_vulns[pid]["count"]
			count+=1
			exploitable_vulns.update({pid:{"pname":pname,"psolution":psolution,"severity":severity,"pdesc":pdesc,"psynopsis":psynopsis,"assets":assets,"count":count}})
		else:
			exploitable_vulns.update({pid:{"pname":pname,"psolution":psolution,"severity":severity,"pdesc":pdesc,"psynopsis":psynopsis,"assets":[ipv4],"count":1}})

sorted_dct=dict(sorted(exploitable_vulns.items(), key=lambda item: item[1]["count"], reverse=True))
rt.vuln_report_by_plugin(sorted_dct,reports_file,styles_dir)
